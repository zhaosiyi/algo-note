<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width, target-densitydpi=device-dpi">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="format-detection" content="telephone=no">
    <meta name="format-detection" content="email=no">
    <title>Blog</title>
    <link rel="stylesheet" href="../../css/materialize.min.css" charset="utf-8">
    <link rel="stylesheet" href="../../css/prism.css" charset="utf-8">
    <link rel="stylesheet" href="../../css/article.css" charset="utf-8">
</head>
<body>
<header class="blue darken-2 white-text z-depth-1">
    <a id="home" class="white-text" href="../../index.html">Zhaosiyi's Blog</a>
</header>
<div id="main" class="row">
<div id="content" class="col m7 s12">
    <h1 id="main-title">《算法谜题》笔记</h1>
    <div>
        <span>创建日期：2016-10-30</span>
    </div>
    <blockquote>
<p>书籍信息：《算法谜题》，[美]Anany Levitin, Maria Levitin 著，人民邮电出版社。</p>
</blockquote>
<div class="heading-high scrollspy"><h2>1.1 算法设计的若干通用策略</h1><div class="divider"></div></div>
<p>包含算法：</p>
<ul>
<li><p>穷举搜索（exhaustive search）</p></li>
<li><p>回溯法（backtracking）</p></li>
<li><p>减治法（decrease-and-conquer）</p></li>
</ul>
<div class="heading-high scrollspy"><h2>1.1.1 穷举搜索</h1><div class="divider"></div></div>
<p>即生成所有可能的解，然后一一检查解是否正确。</p>
<p>其时间复杂度通常为阶乘级别，效率低下，但适用范围广泛。</p>
<div class="heading-high scrollspy"><h2>1.1.2 回溯法</h1><div class="divider"></div></div>
<p>基本思路和穷举搜索类似，但回溯法在一个解还未构造完成时就开始不断评估这个“半成品”。当它断定这个“半成品”在完成后也一定不正确时，便停止构造当前解，返回去构造下一个解。</p>
<p>其核心思想在于：将一个完整的解分成一个个部件，每次选择一个符合要求的部件，如果找不到下一个“合法”部件时，便回头去尝试下一个合法部件，直至“拼出”整个完整的解。</p>
<div class="heading-low scrollspy"><h3>例题：八皇后问题</h2></div>
<blockquote>
<p>在一个国际象棋棋盘上摆放 8 个皇后，使得任意两个皇后无法相互攻击。求出所有摆放方案。</p>
</blockquote>
<p>如果用穷举搜索，那么算法的过程为：</p>
<ul>
<li><p>先摆上 8 个皇后。</p></li>
<li><p>检查这 8 个皇后是否能相互攻击。</p></li>
<li><p>尝试下一种摆法，进行检查……</p></li>
</ul>
<p>事实上，在我们摆第 n 个皇后时（0&amp;lt;n&amp;lt;=8），只要它和前面摆放的任意一个皇后冲突，无论以后的皇后怎么摆，这种摆法都不可能正确。因此就不必继续尝试了，回头去寻找下一个合适的位置重新开始尝试即可。这样便大大减少了尝试的次数，提高了效率。</p>
<p>回溯法的过程为：</p>
<ul>
<li><p>枚举第一个皇后的位置，摆上第一个皇后。 </p></li>
<li><p>枚举第二个皇后的位置，摆上第二个皇后。如果第二个皇后与之前摆放的皇后冲突，则尝试下一个位置。如果不冲突，则继续摆放下一个皇后。如果所有位置都冲突，则重新摆放前一个皇后的位置。</p></li>
<li><p>以此类推，摆放其余皇后。</p></li>
<li><p>如果成功摆上 8 个皇后，此时的摆法为一个正确的解。</p></li>
</ul>
<div class="heading-high scrollspy"><h2>1.1.3 减治法</h1><div class="divider"></div></div>
<p>减治法的核心在于：想办法减小原问题的规模，并使得新问题（规模更小的问题）的解和原问题（规模更大的问题）的解相同。并由此递归计算，直至问题的规模小到能直接求解，从而解决原问题。</p>
<div class="heading-low scrollspy"><h3>例题：名流问题</h2></div>
<blockquote>
<p>在人数为 n 的人群中的名流，是指他（她）不认识任何人，而所有人都认识他（她）的人。每次可询问一个人认识的人的列表，求出人群中所有的名流（当然，也可能不存在名流）。</p>
</blockquote>
<p>开始时，名流的可能人选有 n 个（即人人都可能是名流）。当询问甲时，如果甲认识乙，则甲一定不是名流。此时名流的候选人就变成 n-1 个。如果甲不认识乙，那么乙也不可能是名流，名流候选人就又少了一个。如此询问下去，名流的候选人不断减少，但这少数人中的真正名流和最开始的 n 个人中的真正名流依然相同，询问完所有人后，剩下的候选人便是“真正的名流”。在这过程中候选人人数（问题的规模）不断减少，但答案没变，最终剩下的候选人就直接是答案（即问题简单到能直接求解）。这就是减治法。</p>

    <hr>
    <span>End.</span>
</div>
<div id="directory" class="col m5 hide-on-small-only"></div>
</div>
<script src="../../js/jquery-3.0.0.min.js"></script>
<script src="../../js/materialize.min.js"></script>
<script src="../../js/prism.js"></script>
<script src="../../js/article.js"></script>

</body>
</html>